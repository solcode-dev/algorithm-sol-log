#include <math.h>
#include <stdio.h>

/*
 * ============================================
 * 프로그래머스: 점 찍기
 * ============================================
 *
 * [문제 요약]
 * - 원점(0,0)에서 거리가 d 이하인 점들 중
 * - x좌표와 y좌표가 모두 k의 배수인 점의 개수를 세기
 *
 * [핵심 수학 개념]
 *
 * 1. 거리 공식 (피타고라스 정리)
 *    - 점 (x, y)와 원점 사이 거리 = √(x² + y²)
 *
 * 2. 조건 변환 (루트 제거)
 *    - 거리 ≤ d
 *    - √(x² + y²) ≤ d
 *    - x² + y² ≤ d²  (양변 제곱)
 *
 * 3. y의 최대값 구하기 (x가 정해졌을 때)
 *    - x² + y² ≤ d²
 *    - y² ≤ d² - x²
 *    - y ≤ √(d² - x²)
 *
 * 4. k의 배수 개수 세기
 *    - 0부터 max_y까지 k의 배수: 0, k, 2k, 3k, ...
 *    - 개수 = (max_y / k) + 1
 *    - +1 하는 이유: y=0도 포함해야 하니까
 */

long long solution(int k, int d) {

  // 점의 개수를 저장할 변수
  // long long 쓰는 이유:
  long long answer = 0;

  // d제곱을 미리 계산한다
  // d가 100만이면 d*d는 1조가 되니까 int 범위를 초과한다
  long long d_sq = (long long)d * d;

  // x를 0, k, 2k, 3k... 순서로 확인 (d 이하까지)
  for (long long x = 0; x <= d; x += k) {
    // 현재 x에서 y의 최대값
    // y ≤ √(d² - x²)
    long long max_y = (long long)sqrt((double)(d_sq - x * x));

    // 0부터 max_y까지 중에 k의 배수 개수 확인
    long long count = (max_y / k) + 1;

    // 이 x에서 가능한 점 개수를 더한다
    answer += count;
  }

  return answer;

  /*
   * ============================================
   * 왜 빠른가?
   * ============================================
   *
   * [원래 방법]
   * x 하나당 y를 전부 확인 → (d/k) × (d/k) = (d/k)² 번 반복
   * k=1, d=100만이면 → 1조 번 반복 → 시간 초과!
   *
   * [개선된 방법]
   * x 하나당 y 개수를 계산으로 바로 구함 → (d/k) 번 반복
   * k=1, d=100만이면 → 100만 번 반복 → 통과!
   *
   * ============================================
   * 예시로 확인 (k=2, d=4)
   * ============================================
   *
   * x=0일 때:
   *   max_y = √(16 - 0) = 4
   *   count = 4/2 + 1 = 3  → y = 0, 2, 4
   *
   * x=2일 때:
   *   max_y = √(16 - 4) = √12 ≈ 3.46 → 정수로 3
   *   count = 3/2 + 1 = 2  → y = 0, 2
   *
   * x=4일 때:
   *   max_y = √(16 - 16) = 0
   *   count = 0/2 + 1 = 1  → y = 0
   *
   * 총 개수 = 3 + 2 + 1 = 6개 ✓
   */
}