# Week 02 알고리즘 학습 복기

## 학습 기간
Week 02

## 풀이한 문제 목록

### 백준
1. [bj-10799.cpp](bj-10799.cpp) - 쇠막대기 (스택)
2. [bj-1406.cpp](bj-1406.cpp) - 에디터 (스택 2개)
3. [bj-1676.cpp](bj-1676.cpp) - 팩토리얼 0의 개수 (수학)
4. [bj-17298.cpp](bj-17298.cpp) - 오큰수 (스택)
5. [bj-17413.cpp](bj-17413.cpp) - 단어 뒤집기 2 (스택, 문자열)
6. [bj-1874.cpp](bj-1874.cpp) - 스택 수열 (스택)
7. [bj-1929.cpp](bj-1929.cpp) - 소수 구하기 (에라토스테네스의 체)

### 프로그래머스
1. [progmrs-문자열뒤집기.cpp](progmrs-문자열뒤집기.cpp) - 문자열 뒤집기 (스택)
2. [progmrs-소수찾기.cpp](progmrs-소수찾기.cpp) - 소수 찾기 (에라토스테네스의 체)
3. [progmrs-올바른괄호.cpp](progmrs-올바른괄호.cpp) - 올바른 괄호 (스택)
4. [progmrs-최대공약수와최소공배수.cpp](progmrs-최대공약수와최소공배수.cpp) - 최대공약수와 최소공배수 (유클리드 호제법)

### 구름
1. [goorm-골드바흐추측찾기.cpp](goorm-골드바흐추측찾기.cpp) - 골드바흐 파티션 (소수, 에라토스테네스의 체)

**총 풀이 문제 수: 12문제**

---

## 주요 학습 내용

### 1. 자료구조

#### 스택 (Stack)
- **기본 개념**: LIFO (Last In First Out) 구조
- **C++ STL**: `#include <stack>`
- **주요 메서드**:
  - `push()`: 스택에 삽입
  - `pop()`: 스택에서 제거
  - `top()`: 스택의 맨 위 원소 확인
  - `empty()`: 스택이 비어있는지 확인
  - `size()`: 스택의 크기

#### 스택 활용 패턴

##### 1) 괄호 검사
- 문제: [progmrs-올바른괄호.cpp](progmrs-올바른괄호.cpp)
- 학습 내용:
  - 여는 괄호 `(`: 카운터 증가
  - 닫는 괄호 `)`: 카운터 감소
  - 카운터가 음수가 되면 즉시 `false` (닫는 괄호가 더 많음)
  - 최종적으로 카운터가 0이어야 올바른 괄호
- 최적화: 스택 없이 카운터만으로 해결 가능

##### 2) 문자열 뒤집기
- 문제: [progmrs-문자열뒤집기.cpp](progmrs-문자열뒤집기.cpp), [bj-17413.cpp](bj-17413.cpp)
- 학습 내용:
  - 스택에 문자를 순서대로 넣고 꺼내면 역순으로 출력
  - 조건부 뒤집기: 태그 `<>` 안은 뒤집지 않고, 단어만 뒤집기
  - 플래그 변수(`tag`)로 상태 관리

##### 3) 오큰수 (NGE)
- 문제: [bj-17298.cpp](bj-17298.cpp)
- 학습 내용:
  - **오큰수**: 오른쪽에 있으면서 현재 수보다 큰 수 중 가장 왼쪽에 있는 수
  - 스택에 **인덱스**를 저장
  - 현재 원소가 스택 top의 원소보다 크면 → 그게 바로 top의 오큰수
  - 시간복잡도: O(n) (각 원소는 최대 1번 push, 1번 pop)

##### 4) 에디터 (커서 이동)
- 문제: [bj-1406.cpp](bj-1406.cpp)
- 학습 내용:
  - **두 개의 스택** 사용: `left`, `right`
  - 커서는 두 스택 사이에 위치
  - `L` (왼쪽 이동): `left` → `right`로 이동
  - `D` (오른쪽 이동): `right` → `left`로 이동
  - `B` (삭제): `left`에서 `pop()`
  - `P x` (삽입): `left`에 `push(x)`
  - 시간복잡도: O(1) per operation

##### 5) 스택 수열
- 문제: [bj-1874.cpp](bj-1874.cpp)
- 학습 내용:
  - 1~n까지 순서대로 스택에 넣고 빼서 주어진 수열을 만들 수 있는지 판별
  - `m`: 스택에 들어간 마지막 숫자 추적
  - 목표 숫자 `x > m`: `m+1`부터 `x`까지 push 후 pop
  - 목표 숫자 `x <= m`: 스택 top이 `x`인지 확인 후 pop
  - 불가능한 경우: "NO" 출력

##### 6) 쇠막대기
- 문제: [bj-10799.cpp](bj-10799.cpp)
- 학습 내용:
  - 스택에 `(`의 **인덱스** 저장
  - 레이저 판별: `i == s.top() + 1` (연속된 `()`)
  - 레이저인 경우: 현재 스택 크기만큼 조각 추가
  - 쇠막대기 끝인 경우: 1개 추가

### 2. 알고리즘

#### 소수 (Prime Number)

##### 소수 판별
- 파일: [prime_number.cpp](prime_number.cpp)
- 학습 내용:
  - 2부터 `√n`까지만 확인하면 충분
  - `i * i <= n` 조건 사용 (오버플로우 방지)
  - 시간복잡도: O(√n)

##### 에라토스테네스의 체
- 문제: [bj-1929.cpp](bj-1929.cpp), [progmrs-소수찾기.cpp](progmrs-소수찾기.cpp), [goorm-골드바흐추측찾기.cpp](goorm-골드바흐추측찾기.cpp)
- 학습 내용:
  - n 이하의 모든 소수를 찾는 알고리즘
  - `vector<bool> check(n+1, false)`: 지워졌으면 `true`
  - 2부터 시작해서 배수들을 모두 제거
  - **최적화**: `i*i`부터 시작 (`i*2`, `i*3`, ... , `i*(i-1)`은 이미 제거됨)
  - **최적화**: `i*i > n`이면 더 이상 체크 불필요
  - 시간복잡도: O(n log log n)

##### 골드바흐 파티션
- 문제: [goorm-골드바흐추측찾기.cpp](goorm-골드바흐추측찾기.cpp)
- 학습 내용:
  - 골드바흐의 추측: 4 이상의 모든 짝수는 두 소수의 합으로 나타낼 수 있다
  - 에라토스테네스의 체로 n 이하의 소수 구하기
  - 2부터 `n/2`까지 순회하며 `n - i`도 소수인지 확인
  - 순서만 다른 것은 같은 파티션 (중복 제거)

#### 유클리드 호제법 (GCD)
- 파일: [gcd_lcm.cpp](gcd_lcm.cpp), [progmrs-최대공약수와최소공배수.cpp](progmrs-최대공약수와최소공배수.cpp)
- 학습 내용:
  - **최대공약수 (GCD)**: `gcd(a, b) = gcd(b, a % b)`
  - **재귀 구현**: `b == 0`일 때 `a` 반환
  - **반복 구현**: `while (b != 0)` 루프
  - **최소공배수 (LCM)**: `lcm = (a * b) / gcd(a, b)`
  - 시간복잡도: O(log min(a, b))

#### 수학 문제

##### 팩토리얼 0의 개수
- 문제: [bj-1676.cpp](bj-1676.cpp)
- 학습 내용:
  - n!의 끝에 있는 0의 개수 = 10의 개수 = min(2의 개수, 5의 개수)
  - 5의 개수가 항상 2의 개수보다 적음
  - 5의 거듭제곱으로 나눈 몫의 합: `n/5 + n/25 + n/125 + ...`
  - 오버플로우 방지: `i *= 5` 사용

### 3. C++ 문법

#### STL 컨테이너
- `#include <stack>`: 스택
- `#include <vector>`: 동적 배열
- `#include <string>`: 문자열

#### 벡터 초기화
```cpp
vector<int> v(size, initial_value);  // 크기와 초기값 지정
vector<bool> check(n+1, false);      // n+1 크기, false로 초기화
```

#### 범위 기반 for문
```cpp
for (char ch : line) {
    // line의 각 문자에 대해 반복
}
```

#### 입력 처리
- `cin >> variable`: 공백 단위 입력
- `getline(cin, string)`: 한 줄 전체 입력
- `string.length()`: 문자열 길이

#### 형변환 및 오버플로우 방지
```cpp
if ((long long)i * i > n) break;  // int 곱셈 오버플로우 방지
```

---

## 배운 점

### 긍정적인 점
1. **Python에서 C++로 전환**: Week 01의 Python에서 Week 02에는 C++로 전환하여 학습
2. **스택 활용 능력 향상**: 다양한 스택 문제를 통해 스택의 활용 패턴 숙달
3. **시간복잡도 최적화**: 에라토스테네스의 체에서 `i*i`부터 시작하는 등 최적화 기법 학습
4. **오답노트 작성**: 6개의 오답노트를 통해 실수와 개선점 기록
5. **상세한 주석**: 코드에 로직을 명확히 설명하는 주석 작성 습관 유지

### 개선이 필요한 점
1. **테스트 코드 제거**: [bj-1929.cpp](bj-1929.cpp)에 테스트용 하드코딩된 값이 남아있음
2. **일관된 코딩 스타일**: 중괄호 위치, 들여쓰기 등 일관성 필요
3. **엣지 케이스 처리**: 빈 스택 체크, 오버플로우 등 예외 상황 체크 강화
4. **변수명 개선**: `a_size`, `NEG` 등 더 명확한 변수명 사용 필요

### 주요 실수 및 해결 (오답노트 기반)
1. **에라토스테네스의 체**: `i*2`가 아닌 `i*i`부터 시작해야 최적화
2. **스택 인덱스 활용**: 값이 아닌 인덱스를 저장하면 더 효율적인 경우가 많음
3. **두 개의 스택**: 커서 이동 문제는 두 개의 스택으로 O(1) 해결 가능
4. **오버플로우 주의**: `i * i`를 계산할 때 `long long` 형변환 필요

---

## 통계
- 총 문제 수: 12문제
- 사용 언어: C++
- 주요 주제: 스택, 소수, 수학
- 오답노트: 6개
